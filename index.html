<!DOCTYPE html><html lang="en" data-astro-cid-wa6wv4kj> <head><meta charset="UTF-8"><meta name="description" content="A Minecraft server network focused on community and creativity."><meta name="viewport" content="width=device-width, initial-scale=1.0"><!-- SEO Meta Tags --><meta property="og:title" content="Mint Network"><meta property="og:description" content="A Minecraft server network focused on community and creativity."><meta property="og:type" content="website"><meta property="og:url" content="https://mint-network.co"><meta property="og:site_name" content="Mint Network"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Mint Network"><meta name="twitter:description" content="A Minecraft server network focused on community and creativity."><!-- Theme Colors --><meta name="theme-color" content="#9a0aab"><meta name="msapplication-TileColor" content="#9a0aab"><!-- Favicon --><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><title>Mint Network</title><!-- Three.js CDN --><script type="module">window.addEventListener("load",()=>{const n=document.getElementById("loading-spinner"),e=document.getElementById("main-content");n&&(n.style.display="none"),e&&e.classList.add("loaded")});setTimeout(()=>{const n=document.getElementById("loading-spinner"),e=document.getElementById("main-content");n&&(n.style.display="none"),e&&e.classList.add("loaded")},3e3);window.copyToClipboard=async(n,e)=>{try{if(await navigator.clipboard.writeText(n),e){const o=e.textContent,t=e.style.color;e.textContent="Copied!",e.style.color="#00a86b",e.style.transform="scale(1.05)",setTimeout(()=>{e.textContent=o,e.style.color=t,e.style.transform=""},2e3)}return!0}catch(o){console.warn("Copy to clipboard failed:",o);try{const t=document.createElement("textarea");if(t.value=n,t.style.position="fixed",t.style.opacity="0",document.body.appendChild(t),t.select(),document.execCommand("copy"),document.body.removeChild(t),e){const a=e.textContent;e.textContent="Copied!",setTimeout(()=>{e.textContent=a},2e3)}return!0}catch(t){return console.warn("Fallback copy failed:",t),!1}}};</script><!-- tsParticles v3 --><script type="module" src="/assets/Landing.astro_astro_type_script_index_1_lang.QOdwnJaL.js"></script><!-- Preconnect to external domains --><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><!-- Preload critical fonts --><link rel="preload" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Rajdhani:wght@400;500;600;700&display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Rajdhani:wght@400;500;600;700&display=swap"></noscript><!-- Critical CSS for loading state --><link rel="stylesheet" href="/assets/index.DXUhFjsV.css">
<link rel="stylesheet" href="/assets/index.TdQ9aDUv.css">
<style>.footer-content[data-astro-cid-sz7xmlte]{display:flex;flex-direction:column;align-items:center;gap:1.5rem}.mobile-divider[data-astro-cid-sz7xmlte]{width:8rem;height:.25rem;background:linear-gradient(135deg,#9a0aab,#b83cc7,#c45adb);border-radius:9999px}.legal-links[data-astro-cid-sz7xmlte]{display:flex;flex-wrap:wrap;justify-content:center;gap:1rem 1.5rem;font-size:.875rem}@media (min-width: 768px){.footer-content[data-astro-cid-sz7xmlte]{flex-direction:row;justify-content:space-between;gap:1rem}.mobile-divider[data-astro-cid-sz7xmlte]{display:none}.legal-links[data-astro-cid-sz7xmlte]{gap:1.5rem;flex-wrap:nowrap}}
</style></head> <body data-astro-cid-wa6wv4kj> <!-- Loading spinner --> <div class="loading-spinner" id="loading-spinner" data-astro-cid-wa6wv4kj></div> <!-- Main content --> <div class="content-loaded" id="main-content" data-astro-cid-wa6wv4kj>  <main class="min-h-screen bg-radial-dark space-bg relative overflow-hidden" data-astro-cid-j7pv25f6> <!-- tsParticles background --> <div id="tsparticles" data-astro-cid-j7pv25f6></div> <!-- Main content --> <div class="relative z-10 min-h-screen flex flex-col items-center justify-center p-8" data-astro-cid-j7pv25f6> <!-- Hero Section --> <div class="text-center mb-16 animate-fade-in" data-astro-cid-j7pv25f6> <div class="mb-8" data-astro-cid-j7pv25f6> <!-- Animated Logo --> <div class="logo-container mb-6" data-astro-cid-j7pv25f6> <img src="/assets/logo_full.D7X3OjDC_Z29O7su.webp" srcset="/assets/logo_full.D7X3OjDC_Z29O7su.webp 1x, /assets/logo_full.D7X3OjDC_22qV7C.webp 2x, /assets/logo_full.D7X3OjDC_ZQwEf.webp 3x" alt="Mint Network" loading="eager" data-astro-cid-j7pv25f6="true" decoding="async" fetchpriority="auto" width="400" height="200" class="logo-main mx-auto"> </div> <div class="w-32 h-1 bg-gradient-royal mx-auto mb-6 rounded-full" data-astro-cid-j7pv25f6></div> <p class="text-2xl md:text-3xl text-text-secondary mb-4 font-light" data-astro-cid-j7pv25f6>
Where creativity meets adventure
</p> <p class="text-lg text-text-muted max-w-2xl mx-auto" data-astro-cid-j7pv25f6>
Join our thriving Minecraft community and explore worlds limited only by your imagination
</p> </div> <!-- Server IP Display --> <div class="server-ip-block bg-dark-medium/20 backdrop-blur-md rounded-2xl p-6 max-w-md mx-auto mb-12 glow-royal border border-royal-primary/20 cursor-pointer transition-all duration-300 hover:bg-dark-light/30 hover:border-royal-primary/40" onclick="copyServerIP(this)" data-astro-cid-j7pv25f6> <p class="text-text-secondary mb-3 text-sm uppercase tracking-wide" data-astro-cid-j7pv25f6>Connect Now</p> <code class="text-royal-primary font-mono text-xl md:text-2xl font-bold block select-all" data-astro-cid-j7pv25f6>
play.mint-network.co
</code> <p class="text-text-muted text-xs mt-2 opacity-70" data-astro-cid-j7pv25f6>
Click to copy
</p> </div> </div> <!-- Navigation Grid --> <div class="navigation-grid w-full max-w-4xl mb-16" data-astro-cid-j7pv25f6> <!-- Vote --> <a href="/vote" class="nav-card group" data-astro-cid-j7pv25f6> <div class="text-center" data-astro-cid-j7pv25f6> <div class="minecraft-item-container mb-4 mx-auto" data-astro-cid-tjwwcb26> <canvas id="canvas-minecraft-item-eix1gmur8" class="minecraft-item-canvas" style="width: 80px; height: 80px;" data-astro-cid-tjwwcb26></canvas> <img id="fallback-minecraft-item-eix1gmur8" src="/images/item-textures/nether-star.png" alt="Vote for us" class="minecraft-item-fallback" style="width: 80px; height: 80px;" data-astro-cid-tjwwcb26> <!-- Hidden texture sources --> <img id="item-minecraft-item-eix1gmur8" src="/images/item-textures/nether-star.png" alt="" style="display: none;" data-astro-cid-tjwwcb26> <img id="enchant-glint-minecraft-item-eix1gmur8" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAMAAACdt4HsAAAABGdBTUEAALGPC/xhBQAAAwBQTFRFGBgYMTExODg4Pz8/QUFBS0tLTk5OT09PUFBQVlZWV1dXWVlZW1tbXV1dXl5eX19fYmJiZ2dnaGhoaWlpampqa2trbGxsbW1tb29vcXFxdHR0eXl5fX19fn5+goKCg4ODhISEhoaGiYmJi4uLj4+PkJCQlJSUlZWVmJiYmpqam5ubnJycoKCgo6OjpqamuLi4vb29xcXFzMzM0dHR2tra3d3d5eXl////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD+Y22gAAAGRJREFUWEftzE0KgCAQBtAc/EUQaRF0/3O1aRUuCiJCSme6R3zvAE+NR7xNcBfnFjkVtn3yT38rDWvX5JMMes9OhWbJCAvXInOVjfNpyGRaFAIECBAgQIAAAQIECBAgQIDg78EHpfzB6tcniosAAAAASUVORK5CYII=" alt="" style="display: none;" data-astro-cid-tjwwcb26> </div>  <script>(function(){const componentId = "minecraft-item-eix1gmur8";
const enableGlint = true;
const rotationOffset = 60;
const size = 12;
const width = 80;
const height = 80;

/**
 * Minecraft Item 3D Renderer
 * Converts 2D pixel art into 3D voxel geometry using modern Three.js BufferGeometry
 */

// ========================================================================================
// PIXEL ART GEOMETRY DEFINITION
// ========================================================================================

function definePixelArtGeometry() {
  if (typeof THREE === 'undefined') return;
  
  /**
   * Custom BufferGeometry that converts 2D pixel art into 3D voxel geometry
   * @param {HTMLCanvasElement} canvas - Source image canvas
   * @param {number} depth - Extrusion depth
   * @param {boolean} useVertexColors - Create individual voxels vs card geometry
   */
  class PixelArtGeometry extends THREE.BufferGeometry {
    constructor(canvas, depth, useVertexColors = false) {
      super();
      
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      const w = canvas.width;
      const h = canvas.height;
      const z = depth;
      const data = ctx.getImageData(0, 0, w, h);
      
      const vertices = [];
      const normals = [];
      const uvs = [];
      const indices = [];
      let vertexIndex = 0;
      
      /**
       * Adds a triangle to the geometry following original Face3 pattern
       */
      const addTriangle = (v1, v2, v3, normal, uv1, uv2, uv3) => {
        vertices.push(...v1, ...v2, ...v3);
        normals.push(...normal, ...normal, ...normal);
        uvs.push(...uv1, ...uv2, ...uv3);
        indices.push(vertexIndex, vertexIndex + 1, vertexIndex + 2);
        vertexIndex += 3;
      };
      
      // Create front and back faces if NOT using vertex colors
      if (!useVertexColors) {
        const frontVerts = [
          [0, 0, z], [w, 0, z], [0, -h, z], [w, -h, z]
        ];
        
        addTriangle(frontVerts[2], frontVerts[1], frontVerts[0], [0, 0, 1], [0, 0], [1, 1], [0, 1]);
        addTriangle(frontVerts[1], frontVerts[2], frontVerts[3], [0, 0, 1], [1, 1], [0, 0], [1, 0]);
        
        const backVerts = [
          [0, 0, 0], [w, 0, 0], [0, -h, 0], [w, -h, 0]
        ];
        
        addTriangle(backVerts[0], backVerts[1], backVerts[2], [0, 0, -1], [0, 1], [1, 1], [0, 0]);
        addTriangle(backVerts[3], backVerts[2], backVerts[1], [0, 0, -1], [1, 0], [0, 0], [1, 1]);
      }
      
      // Process each pixel for voxel geometry
      for (let x = 0; x < w; x++) {
        for (let y = 0; y < h; y++) {
          const pixelIndex = (x + y * data.width) * 4;
          if (!data.data[pixelIndex + 3]) continue; // Skip transparent pixels
          
          // Check for transparent neighbors
          const neighbors = {
            right: x + 1 >= w || !data.data[(x + 1 + y * data.width) * 4 + 3],
            left: x - 1 < 0 || !data.data[(x - 1 + y * data.width) * 4 + 3],
            top: y + 1 >= h || !data.data[(x + (y + 1) * data.width) * 4 + 3],
            bottom: y - 1 < 0 || !data.data[(x + (y - 1) * data.width) * 4 + 3],
          };
          
          // Create individual pixel faces if using vertex colors
          if (useVertexColors) {
            const frontVerts = [
              [x, -y, z], [x + 1, -y, z], [x, -(y + 1), z], [x + 1, -(y + 1), z]
            ];
            
            addTriangle(frontVerts[2], frontVerts[1], frontVerts[0], [0, 0, 1], 
              [x/w, 1-y/h], [(x+1)/w, 1-(y+1)/h], [x/w, 1-(y+1)/h]);
            addTriangle(frontVerts[1], frontVerts[2], frontVerts[3], [0, 0, 1],
              [x/w, 1-y/h], [(x+1)/w, 1-y/h], [(x+1)/w, 1-(y+1)/h]);
            
            const backVerts = [
              [x, -y, 0], [x + 1, -y, 0], [x, -(y + 1), 0], [x + 1, -(y + 1), 0]
            ];
            
            addTriangle(backVerts[0], backVerts[1], backVerts[2], [0, 0, -1],
              [(x+1)/w, 1-y/h], [x/w, 1-(y+1)/h], [(x+1)/w, 1-(y+1)/h]);
            addTriangle(backVerts[3], backVerts[2], backVerts[1], [0, 0, -1],
              [(x+1)/w, 1-y/h], [x/w, 1-y/h], [x/w, 1-(y+1)/h]);
          }
          
          // Create side faces where neighbors are transparent
          if (neighbors.right) {
            const rightVerts = [
              [x + 1, -y, z], [x + 1, -y, 0], [x + 1, -(y + 1), z], [x + 1, -(y + 1), 0]
            ];
            
            addTriangle(rightVerts[2], rightVerts[1], rightVerts[0], [1, 0, 0],
              [x/w, 1-y/h], [(x+1)/w, 1-(y+1)/h], [x/w, 1-(y+1)/h]);
            addTriangle(rightVerts[1], rightVerts[2], rightVerts[3], [1, 0, 0],
              [x/w, 1-y/h], [(x+1)/w, 1-y/h], [(x+1)/w, 1-(y+1)/h]);
          }
          
          if (neighbors.left) {
            const leftVerts = [
              [x, -y, z], [x, -y, 0], [x, -(y + 1), z], [x, -(y + 1), 0]
            ];
            
            addTriangle(leftVerts[0], leftVerts[1], leftVerts[2], [-1, 0, 0],
              [(x+1)/w, 1-y/h], [x/w, 1-(y+1)/h], [(x+1)/w, 1-(y+1)/h]);
            addTriangle(leftVerts[3], leftVerts[2], leftVerts[1], [-1, 0, 0],
              [(x+1)/w, 1-y/h], [x/w, 1-y/h], [x/w, 1-(y+1)/h]);
          }
          
          if (neighbors.top) {
            const topVerts = [
              [x, -(y + 1), z], [x + 1, -(y + 1), z], [x, -(y + 1), 0], [x + 1, -(y + 1), 0]
            ];
            
            addTriangle(topVerts[2], topVerts[1], topVerts[0], [0, -1, 0],
              [x/w, 1-y/h], [(x+1)/w, 1-(y+1)/h], [x/w, 1-(y+1)/h]);
            addTriangle(topVerts[1], topVerts[2], topVerts[3], [0, -1, 0],
              [x/w, 1-y/h], [(x+1)/w, 1-y/h], [(x+1)/w, 1-(y+1)/h]);
          }
          
          if (neighbors.bottom) {
            const bottomVerts = [
              [x, -y, z], [x + 1, -y, z], [x, -y, 0], [x + 1, -y, 0]
            ];
            
            addTriangle(bottomVerts[0], bottomVerts[1], bottomVerts[2], [0, 1, 0],
              [(x+1)/w, 1-y/h], [x/w, 1-(y+1)/h], [(x+1)/w, 1-(y+1)/h]);
            addTriangle(bottomVerts[3], bottomVerts[2], bottomVerts[1], [0, 1, 0],
              [(x+1)/w, 1-y/h], [x/w, 1-y/h], [x/w, 1-(y+1)/h]);
          }
        }
      }
      
      // Finalize geometry
      this.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      this.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
      this.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
      this.setIndex(indices);
      
      this.computeBoundingBox();
      const center = new THREE.Vector3();
      this.boundingBox.getCenter(center);
      this.translate(-center.x, -center.y, -center.z);
    }
  }
  
  THREE.PixelArtGeometry = PixelArtGeometry;
}

// ========================================================================================
// UTILITY FUNCTIONS
// ========================================================================================

function createCanvas(width, height) {
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const context = canvas.getContext('2d', { willReadFrequently: true });
  context.imageSmoothingEnabled = false;
  return { canvas, context };
}

function mergeCanvas(destCanvas, srcCanvas) {
  const srcCtx = srcCanvas.getContext('2d', { willReadFrequently: true });
  const destCtx = destCanvas.getContext('2d', { willReadFrequently: true });
  const { width, height } = srcCanvas;
  const srcData = srcCtx.getImageData(0, 0, width, height);
  const destData = destCtx.getImageData(0, 0, width, height);
  
  const clamp = (value) => Math.max(0, Math.min(255, value));
  
  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      const d = (x + y * width) * 4;
      const r = srcData.data[d];
      const g = srcData.data[d + 1]; 
      const b = srcData.data[d + 2];
      const r2 = destData.data[d];
      const g2 = destData.data[d + 1];
      const b2 = destData.data[d + 2];
      let a2 = srcData.data[d + 3];
      
      const opacity = 0.5;
      a2 = Math.floor(a2 * opacity);
      destData.data[d + 0] = Math.floor(clamp(r * a2 / 255 + (255 - a2) * r2 / 255));
      destData.data[d + 1] = Math.floor(clamp(r * a2 / 255 + (255 - a2) * g2 / 255));
      destData.data[d + 2] = Math.floor(clamp(b * a2 / 255 + (255 - a2) * b2 / 255));
      destData.data[d + 3] = 255;
    }
  }
  
  destCtx.putImageData(destData, 0, 0);
}

function rotateCanvas(context, sourceCanvas, srcX, srcY, srcW, srcH, dstX, dstY, dstW, dstH, angle) {
  const tempCanvas = document.createElement("canvas");
  tempCanvas.width = srcW * 2;
  tempCanvas.height = srcH * 2;
  const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });

  tempCtx.clearRect(0, 0, srcW, srcH);
  const x = srcW / 2;
  const y = srcH / 2;
  const angleInRadians = degToRad(angle);
  tempCtx.translate(x, y);
  tempCtx.rotate(angleInRadians);
  tempCtx.drawImage(sourceCanvas, srcX, srcY, srcW, srcH, -x, -y, srcW, srcH);
  tempCtx.rotate(-angleInRadians);
  tempCtx.translate(-x, -y);

  context.drawImage(tempCanvas, x - dstW / 2, y - dstH / 2, dstW, dstH, dstX, dstY, dstW, dstH);
  tempCanvas.remove();
  return context;
}

function degToRad(deg) {
  return deg * (Math.PI / 180);
}

function hasWebGLSupport() {
  try {
    const canvas = document.createElement('canvas');
    return !!(window.WebGLRenderingContext && (
      canvas.getContext('webgl') || canvas.getContext('experimental-webgl')
    ));
  } catch (e) {
    return false;
  }
}

// ========================================================================================
// ENCHANTMENT GLINT ANIMATION
// ========================================================================================

function generateGlintFrame(cycle) {
  const cycle2 = (cycle + 32) % 56;
  
  // Create unique canvas for this component instance
  const baseCanvas = createCanvas(64, 64);
  baseCanvas.context.fillStyle = "#000000";
  baseCanvas.context.fillRect(0, 0, 64, 64);

  // Get the specific enchant glint image for this component
  const enchantImg = document.getElementById(`enchant-glint-${componentId}`);
  if (!enchantImg) return baseCanvas.canvas;

  const enchantGlint = createCanvas(64, 64);
  enchantGlint.context.drawImage(enchantImg, 0, 0);

  const canvasWidth = Math.sqrt(2) * 64;

  // First rotation layer (80째)
  {
    const stretchCanvas = createCanvas(canvasWidth, canvasWidth);
    stretchCanvas.context.imageSmoothingEnabled = true;
    stretchCanvas.context.drawImage(enchantGlint.canvas, cycle, 0, 8, 64, 0, 0, canvasWidth, canvasWidth);

    const rotatedCanvas = createCanvas(64, 64);
    rotateCanvas(rotatedCanvas.context, stretchCanvas.canvas, 0, 0, canvasWidth, canvasWidth, 0, 0, 64, 64, 80);
    mergeCanvas(baseCanvas.canvas, rotatedCanvas.canvas);
    
    // Clean up this layer's temporary canvases immediately
    stretchCanvas.canvas.remove();
    rotatedCanvas.canvas.remove();
  }

  // Second rotation layer (-10째)
  {
    const stretchCanvas = createCanvas(canvasWidth, canvasWidth);
    stretchCanvas.context.imageSmoothingEnabled = true;
    stretchCanvas.context.drawImage(enchantGlint.canvas, 56 - cycle2, 0, 8, 64, 0, 0, canvasWidth, canvasWidth);

    const rotatedCanvas = createCanvas(64, 64);
    rotateCanvas(rotatedCanvas.context, stretchCanvas.canvas, 0, 0, canvasWidth, canvasWidth, 0, 0, 64, 64, -10);
    mergeCanvas(baseCanvas.canvas, rotatedCanvas.canvas);
    
    // Clean up this layer's temporary canvases immediately
    stretchCanvas.canvas.remove();
    rotatedCanvas.canvas.remove();
  }

  // Clean up the enchant glint canvas
  enchantGlint.canvas.remove();

  return baseCanvas.canvas;
}

// ========================================================================================
// MAIN INITIALIZATION
// ========================================================================================

function initMinecraftItem() {
  if (!hasWebGLSupport() || typeof THREE === 'undefined') {
    document.querySelector(`#canvas-${componentId}`).parentElement.classList.add('no-webgl');
    return;
  }
  
  definePixelArtGeometry();
  
  const canvas = document.getElementById(`canvas-${componentId}`);
  const itemImg = document.getElementById(`item-${componentId}`);
  let mainObject;
  
  // Wait for image to load
  if (!itemImg.complete) {
    itemImg.onload = () => initThreeJS();
  } else {
    initThreeJS();
  }
  
  function initThreeJS() {
    try {
      // Initialize renderer with transparent background
      const renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: false,
        alpha: true,
        premultipliedAlpha: false
      });
      renderer.setClearColor(0x000000, 0);
      renderer.setSize(width, height);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // Initialize scene
      const scene = new THREE.Scene();

      // Create geometry
      const tempCanvas = createCanvas(itemImg.width, itemImg.height);
      tempCanvas.context.drawImage(itemImg, 0, 0);
      const geometry = new THREE.PixelArtGeometry(tempCanvas.canvas, 1);
      tempCanvas.canvas.remove();
      
      // Create texture
      const texture = new THREE.TextureLoader().load(itemImg.src);
      texture.magFilter = THREE.NearestFilter;
      texture.minFilter = THREE.NearestFilter;
      
      // Create emissive maps for glint animation (each component gets its own)
      let emissiveMaps = [];
      if (enableGlint) {
        for (let i = 0; i < 56; i++) {
          const glintCanvas = generateGlintFrame(i);
          const emissiveTexture = new THREE.CanvasTexture(glintCanvas);
          emissiveTexture.magFilter = THREE.NearestFilter;
          emissiveTexture.minFilter = THREE.NearestFilter;
          emissiveTexture.needsUpdate = true;
          emissiveMaps.push(emissiveTexture);
        }
      }

      // Create material
      const materialConfig = {
        map: texture,
        transparent: true,
        side: THREE.DoubleSide,
        alphaTest: 0.1
      };
      
      if (enableGlint && emissiveMaps.length > 0) {
        materialConfig.emissiveMap = emissiveMaps[0];
        materialConfig.emissive = new THREE.Color("#8f22cf");
        materialConfig.emissiveIntensity = 0.6;
      }
      
      const material = new THREE.MeshLambertMaterial(materialConfig);

      // Create mesh
      const mesh = new THREE.Mesh(geometry, material);
      mesh.scale.set(size, size, size);
      mainObject = mesh;

      // Add object to scene
      scene.add(mainObject);

      // Render function
      function render() {
        // Initialize camera
        const viewSize = 300;
        const aspectRatio = width / height;
        const camera = new THREE.OrthographicCamera(
          -aspectRatio * viewSize / 2,
          aspectRatio * viewSize / 2,
          viewSize / 2,
          -viewSize / 2,
          -1000,
          1000
        );

        camera.position.set(viewSize, viewSize * 0.8168, viewSize);
        camera.lookAt(scene.position);

        // Initialize lighting
        const directionalLight = new THREE.DirectionalLight(0xFFFFFF);
        directionalLight.intensity = 0.435;
        directionalLight.position.set(-1, 2.25, 1.24).normalize();
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        const shadowDistance = 50;
        directionalLight.shadow.camera.left = -shadowDistance;
        directionalLight.shadow.camera.right = shadowDistance;
        directionalLight.shadow.camera.top = shadowDistance;
        directionalLight.shadow.camera.bottom = -shadowDistance;
        directionalLight.shadow.camera.far = 3500;
        directionalLight.shadow.bias = -0.0001;
        scene.add(directionalLight);

        const ambientLight = new THREE.AmbientLight(0xFCFCFF);
        ambientLight.intensity = 0.618;
        scene.add(ambientLight);

        // Begin animation (each component has isolated state)
        let positionCycle = rotationOffset;
        let glintCycle = 0;
        let animationId = null;

        function tick() {
          // Object position and rotation
          positionCycle = positionCycle < 360 ? positionCycle + 1 : 0;
          const yOffset = Math.sin(degToRad(positionCycle * 2)) * 20;
          mainObject.position.set(0, -yOffset, 0);
          mainObject.rotation.set(0, degToRad(positionCycle * 1), 0);
          
          // Switch emissive maps for glint effect (isolated to this component)
          if (enableGlint && emissiveMaps.length > 0) {
            const frameIndex = Math.floor(glintCycle);
            if (frameIndex < emissiveMaps.length) {
              mainObject.material.emissiveMap = emissiveMaps[frameIndex];
              mainObject.material.needsUpdate = true;
            }
            glintCycle = glintCycle < emissiveMaps.length ? glintCycle + 0.17 : 0;
          }

          // Re-render
          renderer.render(scene, camera);
          animationId = requestAnimationFrame(tick);
        }

        // Start animation
        tick();
        
        // Store cleanup function for this component
        window[`cleanup_${componentId}`] = function() {
          if (animationId) {
            cancelAnimationFrame(animationId);
          }
          if (renderer) {
            renderer.dispose();
          }
        };
      }

      render();
      
    } catch (error) {
      console.warn('Failed to initialize WebGL item:', error);
      document.querySelector(`#canvas-${componentId}`).parentElement.classList.add('no-webgl');
    }
  }
}

// Initialize when ready (keeping original flow)
document.addEventListener('DOMContentLoaded', function () {
  if (typeof THREE !== 'undefined') {
    initMinecraftItem();
  } else {
    // Wait for Three.js to load
    const checkThree = setInterval(() => {
      if (typeof THREE !== 'undefined') {
        clearInterval(checkThree);
        initMinecraftItem();
      }
    }, 100);
    
    // Fallback after 3 seconds
    setTimeout(() => {
      clearInterval(checkThree);
      if (typeof THREE === 'undefined') {
        document.querySelector(`#canvas-${componentId}`).parentElement.classList.add('no-webgl');
      }
    }, 3000);
  }
});
})();</script> <h3 class="text-lg font-heading font-semibold text-text-primary mb-2" data-astro-cid-j7pv25f6>Vote</h3> <p class="text-sm text-text-muted" data-astro-cid-j7pv25f6>Help us grow</p> </div> </a> <!-- Store --> <a href="/store" class="nav-card group" data-astro-cid-j7pv25f6> <div class="text-center" data-astro-cid-j7pv25f6> <div class="minecraft-item-container mb-4 mx-auto" data-astro-cid-tjwwcb26> <canvas id="canvas-minecraft-item-gmm8q4uxw" class="minecraft-item-canvas" style="width: 80px; height: 80px;" data-astro-cid-tjwwcb26></canvas> <img id="fallback-minecraft-item-gmm8q4uxw" src="/images/item-textures/emerald.png" alt="Store" class="minecraft-item-fallback" style="width: 80px; height: 80px;" data-astro-cid-tjwwcb26> <!-- Hidden texture sources --> <img id="item-minecraft-item-gmm8q4uxw" src="/images/item-textures/emerald.png" alt="" style="display: none;" data-astro-cid-tjwwcb26> <img id="enchant-glint-minecraft-item-gmm8q4uxw" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAMAAACdt4HsAAAABGdBTUEAALGPC/xhBQAAAwBQTFRFGBgYMTExODg4Pz8/QUFBS0tLTk5OT09PUFBQVlZWV1dXWVlZW1tbXV1dXl5eX19fYmJiZ2dnaGhoaWlpampqa2trbGxsbW1tb29vcXFxdHR0eXl5fX19fn5+goKCg4ODhISEhoaGiYmJi4uLj4+PkJCQlJSUlZWVmJiYmpqam5ubnJycoKCgo6OjpqamuLi4vb29xcXFzMzM0dHR2tra3d3d5eXl////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD+Y22gAAAGRJREFUWEftzE0KgCAQBtAc/EUQaRF0/3O1aRUuCiJCSme6R3zvAE+NR7xNcBfnFjkVtn3yT38rDWvX5JMMes9OhWbJCAvXInOVjfNpyGRaFAIECBAgQIAAAQIECBAgQIDg78EHpfzB6tcniosAAAAASUVORK5CYII=" alt="" style="display: none;" data-astro-cid-tjwwcb26> </div>  <script>(function(){const componentId = "minecraft-item-gmm8q4uxw";
const enableGlint = true;
const rotationOffset = 120;
const size = 12;
const width = 80;
const height = 80;

/**
 * Minecraft Item 3D Renderer
 * Converts 2D pixel art into 3D voxel geometry using modern Three.js BufferGeometry
 */

// ========================================================================================
// PIXEL ART GEOMETRY DEFINITION
// ========================================================================================

function definePixelArtGeometry() {
  if (typeof THREE === 'undefined') return;
  
  /**
   * Custom BufferGeometry that converts 2D pixel art into 3D voxel geometry
   * @param {HTMLCanvasElement} canvas - Source image canvas
   * @param {number} depth - Extrusion depth
   * @param {boolean} useVertexColors - Create individual voxels vs card geometry
   */
  class PixelArtGeometry extends THREE.BufferGeometry {
    constructor(canvas, depth, useVertexColors = false) {
      super();
      
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      const w = canvas.width;
      const h = canvas.height;
      const z = depth;
      const data = ctx.getImageData(0, 0, w, h);
      
      const vertices = [];
      const normals = [];
      const uvs = [];
      const indices = [];
      let vertexIndex = 0;
      
      /**
       * Adds a triangle to the geometry following original Face3 pattern
       */
      const addTriangle = (v1, v2, v3, normal, uv1, uv2, uv3) => {
        vertices.push(...v1, ...v2, ...v3);
        normals.push(...normal, ...normal, ...normal);
        uvs.push(...uv1, ...uv2, ...uv3);
        indices.push(vertexIndex, vertexIndex + 1, vertexIndex + 2);
        vertexIndex += 3;
      };
      
      // Create front and back faces if NOT using vertex colors
      if (!useVertexColors) {
        const frontVerts = [
          [0, 0, z], [w, 0, z], [0, -h, z], [w, -h, z]
        ];
        
        addTriangle(frontVerts[2], frontVerts[1], frontVerts[0], [0, 0, 1], [0, 0], [1, 1], [0, 1]);
        addTriangle(frontVerts[1], frontVerts[2], frontVerts[3], [0, 0, 1], [1, 1], [0, 0], [1, 0]);
        
        const backVerts = [
          [0, 0, 0], [w, 0, 0], [0, -h, 0], [w, -h, 0]
        ];
        
        addTriangle(backVerts[0], backVerts[1], backVerts[2], [0, 0, -1], [0, 1], [1, 1], [0, 0]);
        addTriangle(backVerts[3], backVerts[2], backVerts[1], [0, 0, -1], [1, 0], [0, 0], [1, 1]);
      }
      
      // Process each pixel for voxel geometry
      for (let x = 0; x < w; x++) {
        for (let y = 0; y < h; y++) {
          const pixelIndex = (x + y * data.width) * 4;
          if (!data.data[pixelIndex + 3]) continue; // Skip transparent pixels
          
          // Check for transparent neighbors
          const neighbors = {
            right: x + 1 >= w || !data.data[(x + 1 + y * data.width) * 4 + 3],
            left: x - 1 < 0 || !data.data[(x - 1 + y * data.width) * 4 + 3],
            top: y + 1 >= h || !data.data[(x + (y + 1) * data.width) * 4 + 3],
            bottom: y - 1 < 0 || !data.data[(x + (y - 1) * data.width) * 4 + 3],
          };
          
          // Create individual pixel faces if using vertex colors
          if (useVertexColors) {
            const frontVerts = [
              [x, -y, z], [x + 1, -y, z], [x, -(y + 1), z], [x + 1, -(y + 1), z]
            ];
            
            addTriangle(frontVerts[2], frontVerts[1], frontVerts[0], [0, 0, 1], 
              [x/w, 1-y/h], [(x+1)/w, 1-(y+1)/h], [x/w, 1-(y+1)/h]);
            addTriangle(frontVerts[1], frontVerts[2], frontVerts[3], [0, 0, 1],
              [x/w, 1-y/h], [(x+1)/w, 1-y/h], [(x+1)/w, 1-(y+1)/h]);
            
            const backVerts = [
              [x, -y, 0], [x + 1, -y, 0], [x, -(y + 1), 0], [x + 1, -(y + 1), 0]
            ];
            
            addTriangle(backVerts[0], backVerts[1], backVerts[2], [0, 0, -1],
              [(x+1)/w, 1-y/h], [x/w, 1-(y+1)/h], [(x+1)/w, 1-(y+1)/h]);
            addTriangle(backVerts[3], backVerts[2], backVerts[1], [0, 0, -1],
              [(x+1)/w, 1-y/h], [x/w, 1-y/h], [x/w, 1-(y+1)/h]);
          }
          
          // Create side faces where neighbors are transparent
          if (neighbors.right) {
            const rightVerts = [
              [x + 1, -y, z], [x + 1, -y, 0], [x + 1, -(y + 1), z], [x + 1, -(y + 1), 0]
            ];
            
            addTriangle(rightVerts[2], rightVerts[1], rightVerts[0], [1, 0, 0],
              [x/w, 1-y/h], [(x+1)/w, 1-(y+1)/h], [x/w, 1-(y+1)/h]);
            addTriangle(rightVerts[1], rightVerts[2], rightVerts[3], [1, 0, 0],
              [x/w, 1-y/h], [(x+1)/w, 1-y/h], [(x+1)/w, 1-(y+1)/h]);
          }
          
          if (neighbors.left) {
            const leftVerts = [
              [x, -y, z], [x, -y, 0], [x, -(y + 1), z], [x, -(y + 1), 0]
            ];
            
            addTriangle(leftVerts[0], leftVerts[1], leftVerts[2], [-1, 0, 0],
              [(x+1)/w, 1-y/h], [x/w, 1-(y+1)/h], [(x+1)/w, 1-(y+1)/h]);
            addTriangle(leftVerts[3], leftVerts[2], leftVerts[1], [-1, 0, 0],
              [(x+1)/w, 1-y/h], [x/w, 1-y/h], [x/w, 1-(y+1)/h]);
          }
          
          if (neighbors.top) {
            const topVerts = [
              [x, -(y + 1), z], [x + 1, -(y + 1), z], [x, -(y + 1), 0], [x + 1, -(y + 1), 0]
            ];
            
            addTriangle(topVerts[2], topVerts[1], topVerts[0], [0, -1, 0],
              [x/w, 1-y/h], [(x+1)/w, 1-(y+1)/h], [x/w, 1-(y+1)/h]);
            addTriangle(topVerts[1], topVerts[2], topVerts[3], [0, -1, 0],
              [x/w, 1-y/h], [(x+1)/w, 1-y/h], [(x+1)/w, 1-(y+1)/h]);
          }
          
          if (neighbors.bottom) {
            const bottomVerts = [
              [x, -y, z], [x + 1, -y, z], [x, -y, 0], [x + 1, -y, 0]
            ];
            
            addTriangle(bottomVerts[0], bottomVerts[1], bottomVerts[2], [0, 1, 0],
              [(x+1)/w, 1-y/h], [x/w, 1-(y+1)/h], [(x+1)/w, 1-(y+1)/h]);
            addTriangle(bottomVerts[3], bottomVerts[2], bottomVerts[1], [0, 1, 0],
              [(x+1)/w, 1-y/h], [x/w, 1-y/h], [x/w, 1-(y+1)/h]);
          }
        }
      }
      
      // Finalize geometry
      this.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      this.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
      this.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
      this.setIndex(indices);
      
      this.computeBoundingBox();
      const center = new THREE.Vector3();
      this.boundingBox.getCenter(center);
      this.translate(-center.x, -center.y, -center.z);
    }
  }
  
  THREE.PixelArtGeometry = PixelArtGeometry;
}

// ========================================================================================
// UTILITY FUNCTIONS
// ========================================================================================

function createCanvas(width, height) {
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const context = canvas.getContext('2d', { willReadFrequently: true });
  context.imageSmoothingEnabled = false;
  return { canvas, context };
}

function mergeCanvas(destCanvas, srcCanvas) {
  const srcCtx = srcCanvas.getContext('2d', { willReadFrequently: true });
  const destCtx = destCanvas.getContext('2d', { willReadFrequently: true });
  const { width, height } = srcCanvas;
  const srcData = srcCtx.getImageData(0, 0, width, height);
  const destData = destCtx.getImageData(0, 0, width, height);
  
  const clamp = (value) => Math.max(0, Math.min(255, value));
  
  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      const d = (x + y * width) * 4;
      const r = srcData.data[d];
      const g = srcData.data[d + 1]; 
      const b = srcData.data[d + 2];
      const r2 = destData.data[d];
      const g2 = destData.data[d + 1];
      const b2 = destData.data[d + 2];
      let a2 = srcData.data[d + 3];
      
      const opacity = 0.5;
      a2 = Math.floor(a2 * opacity);
      destData.data[d + 0] = Math.floor(clamp(r * a2 / 255 + (255 - a2) * r2 / 255));
      destData.data[d + 1] = Math.floor(clamp(r * a2 / 255 + (255 - a2) * g2 / 255));
      destData.data[d + 2] = Math.floor(clamp(b * a2 / 255 + (255 - a2) * b2 / 255));
      destData.data[d + 3] = 255;
    }
  }
  
  destCtx.putImageData(destData, 0, 0);
}

function rotateCanvas(context, sourceCanvas, srcX, srcY, srcW, srcH, dstX, dstY, dstW, dstH, angle) {
  const tempCanvas = document.createElement("canvas");
  tempCanvas.width = srcW * 2;
  tempCanvas.height = srcH * 2;
  const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });

  tempCtx.clearRect(0, 0, srcW, srcH);
  const x = srcW / 2;
  const y = srcH / 2;
  const angleInRadians = degToRad(angle);
  tempCtx.translate(x, y);
  tempCtx.rotate(angleInRadians);
  tempCtx.drawImage(sourceCanvas, srcX, srcY, srcW, srcH, -x, -y, srcW, srcH);
  tempCtx.rotate(-angleInRadians);
  tempCtx.translate(-x, -y);

  context.drawImage(tempCanvas, x - dstW / 2, y - dstH / 2, dstW, dstH, dstX, dstY, dstW, dstH);
  tempCanvas.remove();
  return context;
}

function degToRad(deg) {
  return deg * (Math.PI / 180);
}

function hasWebGLSupport() {
  try {
    const canvas = document.createElement('canvas');
    return !!(window.WebGLRenderingContext && (
      canvas.getContext('webgl') || canvas.getContext('experimental-webgl')
    ));
  } catch (e) {
    return false;
  }
}

// ========================================================================================
// ENCHANTMENT GLINT ANIMATION
// ========================================================================================

function generateGlintFrame(cycle) {
  const cycle2 = (cycle + 32) % 56;
  
  // Create unique canvas for this component instance
  const baseCanvas = createCanvas(64, 64);
  baseCanvas.context.fillStyle = "#000000";
  baseCanvas.context.fillRect(0, 0, 64, 64);

  // Get the specific enchant glint image for this component
  const enchantImg = document.getElementById(`enchant-glint-${componentId}`);
  if (!enchantImg) return baseCanvas.canvas;

  const enchantGlint = createCanvas(64, 64);
  enchantGlint.context.drawImage(enchantImg, 0, 0);

  const canvasWidth = Math.sqrt(2) * 64;

  // First rotation layer (80째)
  {
    const stretchCanvas = createCanvas(canvasWidth, canvasWidth);
    stretchCanvas.context.imageSmoothingEnabled = true;
    stretchCanvas.context.drawImage(enchantGlint.canvas, cycle, 0, 8, 64, 0, 0, canvasWidth, canvasWidth);

    const rotatedCanvas = createCanvas(64, 64);
    rotateCanvas(rotatedCanvas.context, stretchCanvas.canvas, 0, 0, canvasWidth, canvasWidth, 0, 0, 64, 64, 80);
    mergeCanvas(baseCanvas.canvas, rotatedCanvas.canvas);
    
    // Clean up this layer's temporary canvases immediately
    stretchCanvas.canvas.remove();
    rotatedCanvas.canvas.remove();
  }

  // Second rotation layer (-10째)
  {
    const stretchCanvas = createCanvas(canvasWidth, canvasWidth);
    stretchCanvas.context.imageSmoothingEnabled = true;
    stretchCanvas.context.drawImage(enchantGlint.canvas, 56 - cycle2, 0, 8, 64, 0, 0, canvasWidth, canvasWidth);

    const rotatedCanvas = createCanvas(64, 64);
    rotateCanvas(rotatedCanvas.context, stretchCanvas.canvas, 0, 0, canvasWidth, canvasWidth, 0, 0, 64, 64, -10);
    mergeCanvas(baseCanvas.canvas, rotatedCanvas.canvas);
    
    // Clean up this layer's temporary canvases immediately
    stretchCanvas.canvas.remove();
    rotatedCanvas.canvas.remove();
  }

  // Clean up the enchant glint canvas
  enchantGlint.canvas.remove();

  return baseCanvas.canvas;
}

// ========================================================================================
// MAIN INITIALIZATION
// ========================================================================================

function initMinecraftItem() {
  if (!hasWebGLSupport() || typeof THREE === 'undefined') {
    document.querySelector(`#canvas-${componentId}`).parentElement.classList.add('no-webgl');
    return;
  }
  
  definePixelArtGeometry();
  
  const canvas = document.getElementById(`canvas-${componentId}`);
  const itemImg = document.getElementById(`item-${componentId}`);
  let mainObject;
  
  // Wait for image to load
  if (!itemImg.complete) {
    itemImg.onload = () => initThreeJS();
  } else {
    initThreeJS();
  }
  
  function initThreeJS() {
    try {
      // Initialize renderer with transparent background
      const renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: false,
        alpha: true,
        premultipliedAlpha: false
      });
      renderer.setClearColor(0x000000, 0);
      renderer.setSize(width, height);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // Initialize scene
      const scene = new THREE.Scene();

      // Create geometry
      const tempCanvas = createCanvas(itemImg.width, itemImg.height);
      tempCanvas.context.drawImage(itemImg, 0, 0);
      const geometry = new THREE.PixelArtGeometry(tempCanvas.canvas, 1);
      tempCanvas.canvas.remove();
      
      // Create texture
      const texture = new THREE.TextureLoader().load(itemImg.src);
      texture.magFilter = THREE.NearestFilter;
      texture.minFilter = THREE.NearestFilter;
      
      // Create emissive maps for glint animation (each component gets its own)
      let emissiveMaps = [];
      if (enableGlint) {
        for (let i = 0; i < 56; i++) {
          const glintCanvas = generateGlintFrame(i);
          const emissiveTexture = new THREE.CanvasTexture(glintCanvas);
          emissiveTexture.magFilter = THREE.NearestFilter;
          emissiveTexture.minFilter = THREE.NearestFilter;
          emissiveTexture.needsUpdate = true;
          emissiveMaps.push(emissiveTexture);
        }
      }

      // Create material
      const materialConfig = {
        map: texture,
        transparent: true,
        side: THREE.DoubleSide,
        alphaTest: 0.1
      };
      
      if (enableGlint && emissiveMaps.length > 0) {
        materialConfig.emissiveMap = emissiveMaps[0];
        materialConfig.emissive = new THREE.Color("#8f22cf");
        materialConfig.emissiveIntensity = 0.6;
      }
      
      const material = new THREE.MeshLambertMaterial(materialConfig);

      // Create mesh
      const mesh = new THREE.Mesh(geometry, material);
      mesh.scale.set(size, size, size);
      mainObject = mesh;

      // Add object to scene
      scene.add(mainObject);

      // Render function
      function render() {
        // Initialize camera
        const viewSize = 300;
        const aspectRatio = width / height;
        const camera = new THREE.OrthographicCamera(
          -aspectRatio * viewSize / 2,
          aspectRatio * viewSize / 2,
          viewSize / 2,
          -viewSize / 2,
          -1000,
          1000
        );

        camera.position.set(viewSize, viewSize * 0.8168, viewSize);
        camera.lookAt(scene.position);

        // Initialize lighting
        const directionalLight = new THREE.DirectionalLight(0xFFFFFF);
        directionalLight.intensity = 0.435;
        directionalLight.position.set(-1, 2.25, 1.24).normalize();
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        const shadowDistance = 50;
        directionalLight.shadow.camera.left = -shadowDistance;
        directionalLight.shadow.camera.right = shadowDistance;
        directionalLight.shadow.camera.top = shadowDistance;
        directionalLight.shadow.camera.bottom = -shadowDistance;
        directionalLight.shadow.camera.far = 3500;
        directionalLight.shadow.bias = -0.0001;
        scene.add(directionalLight);

        const ambientLight = new THREE.AmbientLight(0xFCFCFF);
        ambientLight.intensity = 0.618;
        scene.add(ambientLight);

        // Begin animation (each component has isolated state)
        let positionCycle = rotationOffset;
        let glintCycle = 0;
        let animationId = null;

        function tick() {
          // Object position and rotation
          positionCycle = positionCycle < 360 ? positionCycle + 1 : 0;
          const yOffset = Math.sin(degToRad(positionCycle * 2)) * 20;
          mainObject.position.set(0, -yOffset, 0);
          mainObject.rotation.set(0, degToRad(positionCycle * 1), 0);
          
          // Switch emissive maps for glint effect (isolated to this component)
          if (enableGlint && emissiveMaps.length > 0) {
            const frameIndex = Math.floor(glintCycle);
            if (frameIndex < emissiveMaps.length) {
              mainObject.material.emissiveMap = emissiveMaps[frameIndex];
              mainObject.material.needsUpdate = true;
            }
            glintCycle = glintCycle < emissiveMaps.length ? glintCycle + 0.17 : 0;
          }

          // Re-render
          renderer.render(scene, camera);
          animationId = requestAnimationFrame(tick);
        }

        // Start animation
        tick();
        
        // Store cleanup function for this component
        window[`cleanup_${componentId}`] = function() {
          if (animationId) {
            cancelAnimationFrame(animationId);
          }
          if (renderer) {
            renderer.dispose();
          }
        };
      }

      render();
      
    } catch (error) {
      console.warn('Failed to initialize WebGL item:', error);
      document.querySelector(`#canvas-${componentId}`).parentElement.classList.add('no-webgl');
    }
  }
}

// Initialize when ready (keeping original flow)
document.addEventListener('DOMContentLoaded', function () {
  if (typeof THREE !== 'undefined') {
    initMinecraftItem();
  } else {
    // Wait for Three.js to load
    const checkThree = setInterval(() => {
      if (typeof THREE !== 'undefined') {
        clearInterval(checkThree);
        initMinecraftItem();
      }
    }, 100);
    
    // Fallback after 3 seconds
    setTimeout(() => {
      clearInterval(checkThree);
      if (typeof THREE === 'undefined') {
        document.querySelector(`#canvas-${componentId}`).parentElement.classList.add('no-webgl');
      }
    }, 3000);
  }
});
})();</script> <h3 class="text-lg font-heading font-semibold text-text-primary mb-2" data-astro-cid-j7pv25f6>Store</h3> <p class="text-sm text-text-muted" data-astro-cid-j7pv25f6>Support the network</p> </div> </a> <!-- Discord --> <a href="https://discord.gg/Un9YA5Z" class="nav-card group" target="_blank" rel="noopener noreferrer" data-astro-cid-j7pv25f6> <div class="text-center" data-astro-cid-j7pv25f6> <div class="minecraft-item-container mb-4 mx-auto" data-astro-cid-tjwwcb26> <canvas id="canvas-minecraft-item-239hn11kx" class="minecraft-item-canvas" style="width: 80px; height: 80px;" data-astro-cid-tjwwcb26></canvas> <img id="fallback-minecraft-item-239hn11kx" src="/images/item-textures/wumpus.png" alt="Discord Community" class="minecraft-item-fallback" style="width: 80px; height: 80px;" data-astro-cid-tjwwcb26> <!-- Hidden texture sources --> <img id="item-minecraft-item-239hn11kx" src="/images/item-textures/wumpus.png" alt="" style="display: none;" data-astro-cid-tjwwcb26> <img id="enchant-glint-minecraft-item-239hn11kx" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAMAAACdt4HsAAAABGdBTUEAALGPC/xhBQAAAwBQTFRFGBgYMTExODg4Pz8/QUFBS0tLTk5OT09PUFBQVlZWV1dXWVlZW1tbXV1dXl5eX19fYmJiZ2dnaGhoaWlpampqa2trbGxsbW1tb29vcXFxdHR0eXl5fX19fn5+goKCg4ODhISEhoaGiYmJi4uLj4+PkJCQlJSUlZWVmJiYmpqam5ubnJycoKCgo6OjpqamuLi4vb29xcXFzMzM0dHR2tra3d3d5eXl////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD+Y22gAAAGRJREFUWEftzE0KgCAQBtAc/EUQaRF0/3O1aRUuCiJCSme6R3zvAE+NR7xNcBfnFjkVtn3yT38rDWvX5JMMes9OhWbJCAvXInOVjfNpyGRaFAIECBAgQIAAAQIECBAgQIDg78EHpfzB6tcniosAAAAASUVORK5CYII=" alt="" style="display: none;" data-astro-cid-tjwwcb26> </div>  <script>(function(){const componentId = "minecraft-item-239hn11kx";
const enableGlint = false;
const rotationOffset = 180;
const size = 12;
const width = 80;
const height = 80;

/**
 * Minecraft Item 3D Renderer
 * Converts 2D pixel art into 3D voxel geometry using modern Three.js BufferGeometry
 */

// ========================================================================================
// PIXEL ART GEOMETRY DEFINITION
// ========================================================================================

function definePixelArtGeometry() {
  if (typeof THREE === 'undefined') return;
  
  /**
   * Custom BufferGeometry that converts 2D pixel art into 3D voxel geometry
   * @param {HTMLCanvasElement} canvas - Source image canvas
   * @param {number} depth - Extrusion depth
   * @param {boolean} useVertexColors - Create individual voxels vs card geometry
   */
  class PixelArtGeometry extends THREE.BufferGeometry {
    constructor(canvas, depth, useVertexColors = false) {
      super();
      
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      const w = canvas.width;
      const h = canvas.height;
      const z = depth;
      const data = ctx.getImageData(0, 0, w, h);
      
      const vertices = [];
      const normals = [];
      const uvs = [];
      const indices = [];
      let vertexIndex = 0;
      
      /**
       * Adds a triangle to the geometry following original Face3 pattern
       */
      const addTriangle = (v1, v2, v3, normal, uv1, uv2, uv3) => {
        vertices.push(...v1, ...v2, ...v3);
        normals.push(...normal, ...normal, ...normal);
        uvs.push(...uv1, ...uv2, ...uv3);
        indices.push(vertexIndex, vertexIndex + 1, vertexIndex + 2);
        vertexIndex += 3;
      };
      
      // Create front and back faces if NOT using vertex colors
      if (!useVertexColors) {
        const frontVerts = [
          [0, 0, z], [w, 0, z], [0, -h, z], [w, -h, z]
        ];
        
        addTriangle(frontVerts[2], frontVerts[1], frontVerts[0], [0, 0, 1], [0, 0], [1, 1], [0, 1]);
        addTriangle(frontVerts[1], frontVerts[2], frontVerts[3], [0, 0, 1], [1, 1], [0, 0], [1, 0]);
        
        const backVerts = [
          [0, 0, 0], [w, 0, 0], [0, -h, 0], [w, -h, 0]
        ];
        
        addTriangle(backVerts[0], backVerts[1], backVerts[2], [0, 0, -1], [0, 1], [1, 1], [0, 0]);
        addTriangle(backVerts[3], backVerts[2], backVerts[1], [0, 0, -1], [1, 0], [0, 0], [1, 1]);
      }
      
      // Process each pixel for voxel geometry
      for (let x = 0; x < w; x++) {
        for (let y = 0; y < h; y++) {
          const pixelIndex = (x + y * data.width) * 4;
          if (!data.data[pixelIndex + 3]) continue; // Skip transparent pixels
          
          // Check for transparent neighbors
          const neighbors = {
            right: x + 1 >= w || !data.data[(x + 1 + y * data.width) * 4 + 3],
            left: x - 1 < 0 || !data.data[(x - 1 + y * data.width) * 4 + 3],
            top: y + 1 >= h || !data.data[(x + (y + 1) * data.width) * 4 + 3],
            bottom: y - 1 < 0 || !data.data[(x + (y - 1) * data.width) * 4 + 3],
          };
          
          // Create individual pixel faces if using vertex colors
          if (useVertexColors) {
            const frontVerts = [
              [x, -y, z], [x + 1, -y, z], [x, -(y + 1), z], [x + 1, -(y + 1), z]
            ];
            
            addTriangle(frontVerts[2], frontVerts[1], frontVerts[0], [0, 0, 1], 
              [x/w, 1-y/h], [(x+1)/w, 1-(y+1)/h], [x/w, 1-(y+1)/h]);
            addTriangle(frontVerts[1], frontVerts[2], frontVerts[3], [0, 0, 1],
              [x/w, 1-y/h], [(x+1)/w, 1-y/h], [(x+1)/w, 1-(y+1)/h]);
            
            const backVerts = [
              [x, -y, 0], [x + 1, -y, 0], [x, -(y + 1), 0], [x + 1, -(y + 1), 0]
            ];
            
            addTriangle(backVerts[0], backVerts[1], backVerts[2], [0, 0, -1],
              [(x+1)/w, 1-y/h], [x/w, 1-(y+1)/h], [(x+1)/w, 1-(y+1)/h]);
            addTriangle(backVerts[3], backVerts[2], backVerts[1], [0, 0, -1],
              [(x+1)/w, 1-y/h], [x/w, 1-y/h], [x/w, 1-(y+1)/h]);
          }
          
          // Create side faces where neighbors are transparent
          if (neighbors.right) {
            const rightVerts = [
              [x + 1, -y, z], [x + 1, -y, 0], [x + 1, -(y + 1), z], [x + 1, -(y + 1), 0]
            ];
            
            addTriangle(rightVerts[2], rightVerts[1], rightVerts[0], [1, 0, 0],
              [x/w, 1-y/h], [(x+1)/w, 1-(y+1)/h], [x/w, 1-(y+1)/h]);
            addTriangle(rightVerts[1], rightVerts[2], rightVerts[3], [1, 0, 0],
              [x/w, 1-y/h], [(x+1)/w, 1-y/h], [(x+1)/w, 1-(y+1)/h]);
          }
          
          if (neighbors.left) {
            const leftVerts = [
              [x, -y, z], [x, -y, 0], [x, -(y + 1), z], [x, -(y + 1), 0]
            ];
            
            addTriangle(leftVerts[0], leftVerts[1], leftVerts[2], [-1, 0, 0],
              [(x+1)/w, 1-y/h], [x/w, 1-(y+1)/h], [(x+1)/w, 1-(y+1)/h]);
            addTriangle(leftVerts[3], leftVerts[2], leftVerts[1], [-1, 0, 0],
              [(x+1)/w, 1-y/h], [x/w, 1-y/h], [x/w, 1-(y+1)/h]);
          }
          
          if (neighbors.top) {
            const topVerts = [
              [x, -(y + 1), z], [x + 1, -(y + 1), z], [x, -(y + 1), 0], [x + 1, -(y + 1), 0]
            ];
            
            addTriangle(topVerts[2], topVerts[1], topVerts[0], [0, -1, 0],
              [x/w, 1-y/h], [(x+1)/w, 1-(y+1)/h], [x/w, 1-(y+1)/h]);
            addTriangle(topVerts[1], topVerts[2], topVerts[3], [0, -1, 0],
              [x/w, 1-y/h], [(x+1)/w, 1-y/h], [(x+1)/w, 1-(y+1)/h]);
          }
          
          if (neighbors.bottom) {
            const bottomVerts = [
              [x, -y, z], [x + 1, -y, z], [x, -y, 0], [x + 1, -y, 0]
            ];
            
            addTriangle(bottomVerts[0], bottomVerts[1], bottomVerts[2], [0, 1, 0],
              [(x+1)/w, 1-y/h], [x/w, 1-(y+1)/h], [(x+1)/w, 1-(y+1)/h]);
            addTriangle(bottomVerts[3], bottomVerts[2], bottomVerts[1], [0, 1, 0],
              [(x+1)/w, 1-y/h], [x/w, 1-y/h], [x/w, 1-(y+1)/h]);
          }
        }
      }
      
      // Finalize geometry
      this.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      this.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
      this.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
      this.setIndex(indices);
      
      this.computeBoundingBox();
      const center = new THREE.Vector3();
      this.boundingBox.getCenter(center);
      this.translate(-center.x, -center.y, -center.z);
    }
  }
  
  THREE.PixelArtGeometry = PixelArtGeometry;
}

// ========================================================================================
// UTILITY FUNCTIONS
// ========================================================================================

function createCanvas(width, height) {
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const context = canvas.getContext('2d', { willReadFrequently: true });
  context.imageSmoothingEnabled = false;
  return { canvas, context };
}

function mergeCanvas(destCanvas, srcCanvas) {
  const srcCtx = srcCanvas.getContext('2d', { willReadFrequently: true });
  const destCtx = destCanvas.getContext('2d', { willReadFrequently: true });
  const { width, height } = srcCanvas;
  const srcData = srcCtx.getImageData(0, 0, width, height);
  const destData = destCtx.getImageData(0, 0, width, height);
  
  const clamp = (value) => Math.max(0, Math.min(255, value));
  
  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      const d = (x + y * width) * 4;
      const r = srcData.data[d];
      const g = srcData.data[d + 1]; 
      const b = srcData.data[d + 2];
      const r2 = destData.data[d];
      const g2 = destData.data[d + 1];
      const b2 = destData.data[d + 2];
      let a2 = srcData.data[d + 3];
      
      const opacity = 0.5;
      a2 = Math.floor(a2 * opacity);
      destData.data[d + 0] = Math.floor(clamp(r * a2 / 255 + (255 - a2) * r2 / 255));
      destData.data[d + 1] = Math.floor(clamp(r * a2 / 255 + (255 - a2) * g2 / 255));
      destData.data[d + 2] = Math.floor(clamp(b * a2 / 255 + (255 - a2) * b2 / 255));
      destData.data[d + 3] = 255;
    }
  }
  
  destCtx.putImageData(destData, 0, 0);
}

function rotateCanvas(context, sourceCanvas, srcX, srcY, srcW, srcH, dstX, dstY, dstW, dstH, angle) {
  const tempCanvas = document.createElement("canvas");
  tempCanvas.width = srcW * 2;
  tempCanvas.height = srcH * 2;
  const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });

  tempCtx.clearRect(0, 0, srcW, srcH);
  const x = srcW / 2;
  const y = srcH / 2;
  const angleInRadians = degToRad(angle);
  tempCtx.translate(x, y);
  tempCtx.rotate(angleInRadians);
  tempCtx.drawImage(sourceCanvas, srcX, srcY, srcW, srcH, -x, -y, srcW, srcH);
  tempCtx.rotate(-angleInRadians);
  tempCtx.translate(-x, -y);

  context.drawImage(tempCanvas, x - dstW / 2, y - dstH / 2, dstW, dstH, dstX, dstY, dstW, dstH);
  tempCanvas.remove();
  return context;
}

function degToRad(deg) {
  return deg * (Math.PI / 180);
}

function hasWebGLSupport() {
  try {
    const canvas = document.createElement('canvas');
    return !!(window.WebGLRenderingContext && (
      canvas.getContext('webgl') || canvas.getContext('experimental-webgl')
    ));
  } catch (e) {
    return false;
  }
}

// ========================================================================================
// ENCHANTMENT GLINT ANIMATION
// ========================================================================================

function generateGlintFrame(cycle) {
  const cycle2 = (cycle + 32) % 56;
  
  // Create unique canvas for this component instance
  const baseCanvas = createCanvas(64, 64);
  baseCanvas.context.fillStyle = "#000000";
  baseCanvas.context.fillRect(0, 0, 64, 64);

  // Get the specific enchant glint image for this component
  const enchantImg = document.getElementById(`enchant-glint-${componentId}`);
  if (!enchantImg) return baseCanvas.canvas;

  const enchantGlint = createCanvas(64, 64);
  enchantGlint.context.drawImage(enchantImg, 0, 0);

  const canvasWidth = Math.sqrt(2) * 64;

  // First rotation layer (80째)
  {
    const stretchCanvas = createCanvas(canvasWidth, canvasWidth);
    stretchCanvas.context.imageSmoothingEnabled = true;
    stretchCanvas.context.drawImage(enchantGlint.canvas, cycle, 0, 8, 64, 0, 0, canvasWidth, canvasWidth);

    const rotatedCanvas = createCanvas(64, 64);
    rotateCanvas(rotatedCanvas.context, stretchCanvas.canvas, 0, 0, canvasWidth, canvasWidth, 0, 0, 64, 64, 80);
    mergeCanvas(baseCanvas.canvas, rotatedCanvas.canvas);
    
    // Clean up this layer's temporary canvases immediately
    stretchCanvas.canvas.remove();
    rotatedCanvas.canvas.remove();
  }

  // Second rotation layer (-10째)
  {
    const stretchCanvas = createCanvas(canvasWidth, canvasWidth);
    stretchCanvas.context.imageSmoothingEnabled = true;
    stretchCanvas.context.drawImage(enchantGlint.canvas, 56 - cycle2, 0, 8, 64, 0, 0, canvasWidth, canvasWidth);

    const rotatedCanvas = createCanvas(64, 64);
    rotateCanvas(rotatedCanvas.context, stretchCanvas.canvas, 0, 0, canvasWidth, canvasWidth, 0, 0, 64, 64, -10);
    mergeCanvas(baseCanvas.canvas, rotatedCanvas.canvas);
    
    // Clean up this layer's temporary canvases immediately
    stretchCanvas.canvas.remove();
    rotatedCanvas.canvas.remove();
  }

  // Clean up the enchant glint canvas
  enchantGlint.canvas.remove();

  return baseCanvas.canvas;
}

// ========================================================================================
// MAIN INITIALIZATION
// ========================================================================================

function initMinecraftItem() {
  if (!hasWebGLSupport() || typeof THREE === 'undefined') {
    document.querySelector(`#canvas-${componentId}`).parentElement.classList.add('no-webgl');
    return;
  }
  
  definePixelArtGeometry();
  
  const canvas = document.getElementById(`canvas-${componentId}`);
  const itemImg = document.getElementById(`item-${componentId}`);
  let mainObject;
  
  // Wait for image to load
  if (!itemImg.complete) {
    itemImg.onload = () => initThreeJS();
  } else {
    initThreeJS();
  }
  
  function initThreeJS() {
    try {
      // Initialize renderer with transparent background
      const renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: false,
        alpha: true,
        premultipliedAlpha: false
      });
      renderer.setClearColor(0x000000, 0);
      renderer.setSize(width, height);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // Initialize scene
      const scene = new THREE.Scene();

      // Create geometry
      const tempCanvas = createCanvas(itemImg.width, itemImg.height);
      tempCanvas.context.drawImage(itemImg, 0, 0);
      const geometry = new THREE.PixelArtGeometry(tempCanvas.canvas, 1);
      tempCanvas.canvas.remove();
      
      // Create texture
      const texture = new THREE.TextureLoader().load(itemImg.src);
      texture.magFilter = THREE.NearestFilter;
      texture.minFilter = THREE.NearestFilter;
      
      // Create emissive maps for glint animation (each component gets its own)
      let emissiveMaps = [];
      if (enableGlint) {
        for (let i = 0; i < 56; i++) {
          const glintCanvas = generateGlintFrame(i);
          const emissiveTexture = new THREE.CanvasTexture(glintCanvas);
          emissiveTexture.magFilter = THREE.NearestFilter;
          emissiveTexture.minFilter = THREE.NearestFilter;
          emissiveTexture.needsUpdate = true;
          emissiveMaps.push(emissiveTexture);
        }
      }

      // Create material
      const materialConfig = {
        map: texture,
        transparent: true,
        side: THREE.DoubleSide,
        alphaTest: 0.1
      };
      
      if (enableGlint && emissiveMaps.length > 0) {
        materialConfig.emissiveMap = emissiveMaps[0];
        materialConfig.emissive = new THREE.Color("#8f22cf");
        materialConfig.emissiveIntensity = 0.6;
      }
      
      const material = new THREE.MeshLambertMaterial(materialConfig);

      // Create mesh
      const mesh = new THREE.Mesh(geometry, material);
      mesh.scale.set(size, size, size);
      mainObject = mesh;

      // Add object to scene
      scene.add(mainObject);

      // Render function
      function render() {
        // Initialize camera
        const viewSize = 300;
        const aspectRatio = width / height;
        const camera = new THREE.OrthographicCamera(
          -aspectRatio * viewSize / 2,
          aspectRatio * viewSize / 2,
          viewSize / 2,
          -viewSize / 2,
          -1000,
          1000
        );

        camera.position.set(viewSize, viewSize * 0.8168, viewSize);
        camera.lookAt(scene.position);

        // Initialize lighting
        const directionalLight = new THREE.DirectionalLight(0xFFFFFF);
        directionalLight.intensity = 0.435;
        directionalLight.position.set(-1, 2.25, 1.24).normalize();
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        const shadowDistance = 50;
        directionalLight.shadow.camera.left = -shadowDistance;
        directionalLight.shadow.camera.right = shadowDistance;
        directionalLight.shadow.camera.top = shadowDistance;
        directionalLight.shadow.camera.bottom = -shadowDistance;
        directionalLight.shadow.camera.far = 3500;
        directionalLight.shadow.bias = -0.0001;
        scene.add(directionalLight);

        const ambientLight = new THREE.AmbientLight(0xFCFCFF);
        ambientLight.intensity = 0.618;
        scene.add(ambientLight);

        // Begin animation (each component has isolated state)
        let positionCycle = rotationOffset;
        let glintCycle = 0;
        let animationId = null;

        function tick() {
          // Object position and rotation
          positionCycle = positionCycle < 360 ? positionCycle + 1 : 0;
          const yOffset = Math.sin(degToRad(positionCycle * 2)) * 20;
          mainObject.position.set(0, -yOffset, 0);
          mainObject.rotation.set(0, degToRad(positionCycle * 1), 0);
          
          // Switch emissive maps for glint effect (isolated to this component)
          if (enableGlint && emissiveMaps.length > 0) {
            const frameIndex = Math.floor(glintCycle);
            if (frameIndex < emissiveMaps.length) {
              mainObject.material.emissiveMap = emissiveMaps[frameIndex];
              mainObject.material.needsUpdate = true;
            }
            glintCycle = glintCycle < emissiveMaps.length ? glintCycle + 0.17 : 0;
          }

          // Re-render
          renderer.render(scene, camera);
          animationId = requestAnimationFrame(tick);
        }

        // Start animation
        tick();
        
        // Store cleanup function for this component
        window[`cleanup_${componentId}`] = function() {
          if (animationId) {
            cancelAnimationFrame(animationId);
          }
          if (renderer) {
            renderer.dispose();
          }
        };
      }

      render();
      
    } catch (error) {
      console.warn('Failed to initialize WebGL item:', error);
      document.querySelector(`#canvas-${componentId}`).parentElement.classList.add('no-webgl');
    }
  }
}

// Initialize when ready (keeping original flow)
document.addEventListener('DOMContentLoaded', function () {
  if (typeof THREE !== 'undefined') {
    initMinecraftItem();
  } else {
    // Wait for Three.js to load
    const checkThree = setInterval(() => {
      if (typeof THREE !== 'undefined') {
        clearInterval(checkThree);
        initMinecraftItem();
      }
    }, 100);
    
    // Fallback after 3 seconds
    setTimeout(() => {
      clearInterval(checkThree);
      if (typeof THREE === 'undefined') {
        document.querySelector(`#canvas-${componentId}`).parentElement.classList.add('no-webgl');
      }
    }, 3000);
  }
});
})();</script> <h3 class="text-lg font-heading font-semibold text-text-primary mb-2" data-astro-cid-j7pv25f6>Discord</h3> <p class="text-sm text-text-muted" data-astro-cid-j7pv25f6>Join the community</p> </div> </a> </div> </div> <!-- Footer --> <footer class="relative z-10 bg-dark-deepest/80 backdrop-blur border-t border-royal-primary/20 py-8 mt-auto" data-astro-cid-sz7xmlte> <div class="container mx-auto px-4" data-astro-cid-sz7xmlte> <div class="footer-content" data-astro-cid-sz7xmlte> <!-- Copyright --> <div class="text-center" data-astro-cid-sz7xmlte> <p class="text-text-muted text-sm" data-astro-cid-sz7xmlte>
짤 2025 Mint Network. All rights reserved.
</p> </div> <!-- Mobile Divider --> <div class="mobile-divider" data-astro-cid-sz7xmlte></div> <!-- Legal Links --> <div class="legal-links" data-astro-cid-sz7xmlte> <a href="/legal/community-guidelines" class="text-text-muted hover:text-text-secondary transition-colors" data-astro-cid-sz7xmlte>
Community Guidelines
</a> <a href="/legal/privacy-policy" class="text-text-muted hover:text-text-secondary transition-colors" data-astro-cid-sz7xmlte>
Privacy Policy
</a> <a href="/legal/store-policies" class="text-text-muted hover:text-text-secondary transition-colors" data-astro-cid-sz7xmlte>
Store Policies
</a> </div> </div> </div> </footer>  </main>  </div> <!-- Global scripts --> <script type="module" src="/assets/Landing.astro_astro_type_script_index_2_lang.C99tDnSG.js"></script> </body> </html>  <script type="module">async function n(){if(typeof tsParticles>"u"){console.warn("tsParticles not loaded");return}try{await tsParticles.load("tsparticles",{background:{color:"transparent"},fpsLimit:60,particles:{color:{value:"#9a0aab"},move:{enable:!0,speed:.5,direction:"none",random:!0,straight:!1,outMode:"bounce"},number:{value:60,density:{enable:!0,value_area:2e3}},opacity:{value:.7,random:!0,anim:{enable:!0,speed:.5,opacity_min:.2}},shape:{type:"circle"},size:{value:2,random:!0,anim:{enable:!0,speed:1,size_min:.5}}},interactivity:{events:{onhover:{enable:!0,mode:"grab"}},modes:{grab:{distance:120,line_linked:{opacity:.1}}}},retina_detect:!0}),console.log("tsParticles initialized successfully")}catch(o){console.error("Failed to initialize tsParticles:",o);const e=document.getElementById("tsparticles");e&&(e.style.display="none")}}window.copyServerIP=async function(o){try{await navigator.clipboard.writeText("play.mint-network.co");const e=o.style.backgroundColor,t=o.querySelector("p:last-child"),a=t?t.textContent:"";o.style.backgroundColor="rgba(0, 168, 107, 0.1)",o.style.borderColor="#00a86b",t&&(t.textContent="Copied to clipboard!",t.style.color="#00a86b"),setTimeout(()=>{o.style.backgroundColor=e,o.style.borderColor="",t&&(t.textContent=a,t.style.color="")},2e3)}catch(e){console.log("Copy failed:",e);const t=o.querySelector("p:last-child"),a=t?t.textContent:"";t&&(t.textContent="Copy failed - please select manually",setTimeout(()=>{t.textContent=a},3e3))}};function r(){document.querySelectorAll('[onclick*="clipboard"]').forEach(e=>{e.addEventListener("click",async()=>{try{await navigator.clipboard.writeText("play.mint-network.co");const t=e.textContent;e.textContent="Copied!",e.style.color="#00a86b",setTimeout(()=>{e.textContent=t,e.style.color=""},2e3)}catch(t){console.log("Copy failed:",t)}})})}document.addEventListener("DOMContentLoaded",()=>{setTimeout(n,200),r()});</script>