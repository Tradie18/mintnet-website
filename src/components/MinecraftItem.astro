---
/**
 * MinecraftItem Component
 * 
 * Converts 2D pixel art into floating 3D voxel objects with optional enchantment glint.
 * Falls back gracefully to flat images when WebGL is unavailable.
 * 
 * (c) 2025 RecursivePixels. All rights reserved. Used under license to Mint Network.
 * Modification and redistribution are not permitted without explicit permission.
 */

export interface Props {
  /** Image source URL or data URL */
  src: string;
  /** Alt text for accessibility */
  alt?: string;
  /** Display width in pixels */
  width?: number;
  /** Display height in pixels */
  height?: number;
  /** Enable animated enchantment glint effect */
  enableGlint?: boolean;
  /** Starting rotation offset in degrees (0-360) */
  rotationOffset?: number;
  /** 3D scale factor */
  size?: number;
  /** Additional CSS classes */
  className?: string;
}

const {
  src,
  alt = "3D Item",
  width = 64,
  height = 64,
  enableGlint = true,
  rotationOffset = 0,
  size = 10,
  className = ""
} = Astro.props;

const componentId = `minecraft-item-${Math.random().toString(36).substr(2, 9)}`;
---

<div class={`minecraft-item-container ${className}`}>
  <canvas 
    id={`canvas-${componentId}`}
    class="minecraft-item-canvas"
    style={`width: ${width}px; height: ${height}px;`}
  ></canvas>
  
  <img 
    id={`fallback-${componentId}`}
    src={src}
    alt={alt}
    class="minecraft-item-fallback"
    style={`width: ${width}px; height: ${height}px;`}
  />
  
  <!-- Hidden texture sources -->
  <img id={`item-${componentId}`} src={src} alt="" style="display: none;" />
  <img 
    id={`enchant-glint-${componentId}`}
    src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAMAAACdt4HsAAAABGdBTUEAALGPC/xhBQAAAwBQTFRFGBgYMTExODg4Pz8/QUFBS0tLTk5OT09PUFBQVlZWV1dXWVlZW1tbXV1dXl5eX19fYmJiZ2dnaGhoaWlpampqa2trbGxsbW1tb29vcXFxdHR0eXl5fX19fn5+goKCg4ODhISEhoaGiYmJi4uLj4+PkJCQlJSUlZWVmJiYmpqam5ubnJycoKCgo6OjpqamuLi4vb29xcXFzMzM0dHR2tra3d3d5eXl////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD+Y22gAAAGRJREFUWEftzE0KgCAQBtAc/EUQaRF0/3O1aRUuCiJCSme6R3zvAE+NR7xNcBfnFjkVtn3yT38rDWvX5JMMes9OhWbJCAvXInOVjfNpyGRaFAIECBAgQIAAAQIECBAgQIDg78EHpfzB6tcniosAAAAASUVORK5CYII="
    alt=""
    style="display: none;"
  />
</div>

<style>
  .minecraft-item-container {
    position: relative;
    display: inline-block;
    cursor: pointer;
    transition: transform 0.2s ease;
  }
  
  .minecraft-item-container:hover {
    transform: scale(1.05);
  }
  
  .minecraft-item-canvas {
    display: block;
    image-rendering: pixelated;
    background: transparent;
  }
  
  .minecraft-item-fallback {
    display: none;
    image-rendering: pixelated;
    filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
  }
  
  .no-webgl .minecraft-item-canvas {
    display: none;
  }
  
  .no-webgl .minecraft-item-fallback {
    display: block;
  }
</style>

<script define:vars={{ componentId, enableGlint, rotationOffset, size, width, height }}>
/**
 * Minecraft Item 3D Renderer
 * Converts 2D pixel art into 3D voxel geometry using modern Three.js BufferGeometry
 */

// ========================================================================================
// PIXEL ART GEOMETRY DEFINITION
// ========================================================================================

function definePixelArtGeometry() {
  if (typeof THREE === 'undefined') return;
  
  /**
   * Custom BufferGeometry that converts 2D pixel art into 3D voxel geometry
   * @param {HTMLCanvasElement} canvas - Source image canvas
   * @param {number} depth - Extrusion depth
   * @param {boolean} useVertexColors - Create individual voxels vs card geometry
   */
  class PixelArtGeometry extends THREE.BufferGeometry {
    constructor(canvas, depth, useVertexColors = false) {
      super();
      
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      const w = canvas.width;
      const h = canvas.height;
      const z = depth;
      const data = ctx.getImageData(0, 0, w, h);
      
      const vertices = [];
      const normals = [];
      const uvs = [];
      const indices = [];
      let vertexIndex = 0;
      
      /**
       * Adds a triangle to the geometry following original Face3 pattern
       */
      const addTriangle = (v1, v2, v3, normal, uv1, uv2, uv3) => {
        vertices.push(...v1, ...v2, ...v3);
        normals.push(...normal, ...normal, ...normal);
        uvs.push(...uv1, ...uv2, ...uv3);
        indices.push(vertexIndex, vertexIndex + 1, vertexIndex + 2);
        vertexIndex += 3;
      };
      
      // Create front and back faces if NOT using vertex colors
      if (!useVertexColors) {
        const frontVerts = [
          [0, 0, z], [w, 0, z], [0, -h, z], [w, -h, z]
        ];
        
        addTriangle(frontVerts[2], frontVerts[1], frontVerts[0], [0, 0, 1], [0, 0], [1, 1], [0, 1]);
        addTriangle(frontVerts[1], frontVerts[2], frontVerts[3], [0, 0, 1], [1, 1], [0, 0], [1, 0]);
        
        const backVerts = [
          [0, 0, 0], [w, 0, 0], [0, -h, 0], [w, -h, 0]
        ];
        
        addTriangle(backVerts[0], backVerts[1], backVerts[2], [0, 0, -1], [0, 1], [1, 1], [0, 0]);
        addTriangle(backVerts[3], backVerts[2], backVerts[1], [0, 0, -1], [1, 0], [0, 0], [1, 1]);
      }
      
      // Process each pixel for voxel geometry
      for (let x = 0; x < w; x++) {
        for (let y = 0; y < h; y++) {
          const pixelIndex = (x + y * data.width) * 4;
          if (!data.data[pixelIndex + 3]) continue; // Skip transparent pixels
          
          // Check for transparent neighbors
          const neighbors = {
            right: x + 1 >= w || !data.data[(x + 1 + y * data.width) * 4 + 3],
            left: x - 1 < 0 || !data.data[(x - 1 + y * data.width) * 4 + 3],
            top: y + 1 >= h || !data.data[(x + (y + 1) * data.width) * 4 + 3],
            bottom: y - 1 < 0 || !data.data[(x + (y - 1) * data.width) * 4 + 3],
          };
          
          // Create individual pixel faces if using vertex colors
          if (useVertexColors) {
            const frontVerts = [
              [x, -y, z], [x + 1, -y, z], [x, -(y + 1), z], [x + 1, -(y + 1), z]
            ];
            
            addTriangle(frontVerts[2], frontVerts[1], frontVerts[0], [0, 0, 1], 
              [x/w, 1-y/h], [(x+1)/w, 1-(y+1)/h], [x/w, 1-(y+1)/h]);
            addTriangle(frontVerts[1], frontVerts[2], frontVerts[3], [0, 0, 1],
              [x/w, 1-y/h], [(x+1)/w, 1-y/h], [(x+1)/w, 1-(y+1)/h]);
            
            const backVerts = [
              [x, -y, 0], [x + 1, -y, 0], [x, -(y + 1), 0], [x + 1, -(y + 1), 0]
            ];
            
            addTriangle(backVerts[0], backVerts[1], backVerts[2], [0, 0, -1],
              [(x+1)/w, 1-y/h], [x/w, 1-(y+1)/h], [(x+1)/w, 1-(y+1)/h]);
            addTriangle(backVerts[3], backVerts[2], backVerts[1], [0, 0, -1],
              [(x+1)/w, 1-y/h], [x/w, 1-y/h], [x/w, 1-(y+1)/h]);
          }
          
          // Create side faces where neighbors are transparent
          if (neighbors.right) {
            const rightVerts = [
              [x + 1, -y, z], [x + 1, -y, 0], [x + 1, -(y + 1), z], [x + 1, -(y + 1), 0]
            ];
            
            addTriangle(rightVerts[2], rightVerts[1], rightVerts[0], [1, 0, 0],
              [x/w, 1-y/h], [(x+1)/w, 1-(y+1)/h], [x/w, 1-(y+1)/h]);
            addTriangle(rightVerts[1], rightVerts[2], rightVerts[3], [1, 0, 0],
              [x/w, 1-y/h], [(x+1)/w, 1-y/h], [(x+1)/w, 1-(y+1)/h]);
          }
          
          if (neighbors.left) {
            const leftVerts = [
              [x, -y, z], [x, -y, 0], [x, -(y + 1), z], [x, -(y + 1), 0]
            ];
            
            addTriangle(leftVerts[0], leftVerts[1], leftVerts[2], [-1, 0, 0],
              [(x+1)/w, 1-y/h], [x/w, 1-(y+1)/h], [(x+1)/w, 1-(y+1)/h]);
            addTriangle(leftVerts[3], leftVerts[2], leftVerts[1], [-1, 0, 0],
              [(x+1)/w, 1-y/h], [x/w, 1-y/h], [x/w, 1-(y+1)/h]);
          }
          
          if (neighbors.top) {
            const topVerts = [
              [x, -(y + 1), z], [x + 1, -(y + 1), z], [x, -(y + 1), 0], [x + 1, -(y + 1), 0]
            ];
            
            addTriangle(topVerts[2], topVerts[1], topVerts[0], [0, -1, 0],
              [x/w, 1-y/h], [(x+1)/w, 1-(y+1)/h], [x/w, 1-(y+1)/h]);
            addTriangle(topVerts[1], topVerts[2], topVerts[3], [0, -1, 0],
              [x/w, 1-y/h], [(x+1)/w, 1-y/h], [(x+1)/w, 1-(y+1)/h]);
          }
          
          if (neighbors.bottom) {
            const bottomVerts = [
              [x, -y, z], [x + 1, -y, z], [x, -y, 0], [x + 1, -y, 0]
            ];
            
            addTriangle(bottomVerts[0], bottomVerts[1], bottomVerts[2], [0, 1, 0],
              [(x+1)/w, 1-y/h], [x/w, 1-(y+1)/h], [(x+1)/w, 1-(y+1)/h]);
            addTriangle(bottomVerts[3], bottomVerts[2], bottomVerts[1], [0, 1, 0],
              [(x+1)/w, 1-y/h], [x/w, 1-y/h], [x/w, 1-(y+1)/h]);
          }
        }
      }
      
      // Finalize geometry
      this.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      this.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
      this.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
      this.setIndex(indices);
      
      this.computeBoundingBox();
      const center = new THREE.Vector3();
      this.boundingBox.getCenter(center);
      this.translate(-center.x, -center.y, -center.z);
    }
  }
  
  THREE.PixelArtGeometry = PixelArtGeometry;
}

// ========================================================================================
// UTILITY FUNCTIONS
// ========================================================================================

function createCanvas(width, height) {
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const context = canvas.getContext('2d', { willReadFrequently: true });
  context.imageSmoothingEnabled = false;
  return { canvas, context };
}

function mergeCanvas(destCanvas, srcCanvas) {
  const srcCtx = srcCanvas.getContext('2d', { willReadFrequently: true });
  const destCtx = destCanvas.getContext('2d', { willReadFrequently: true });
  const { width, height } = srcCanvas;
  const srcData = srcCtx.getImageData(0, 0, width, height);
  const destData = destCtx.getImageData(0, 0, width, height);
  
  const clamp = (value) => Math.max(0, Math.min(255, value));
  
  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      const d = (x + y * width) * 4;
      const r = srcData.data[d];
      const g = srcData.data[d + 1]; 
      const b = srcData.data[d + 2];
      const r2 = destData.data[d];
      const g2 = destData.data[d + 1];
      const b2 = destData.data[d + 2];
      let a2 = srcData.data[d + 3];
      
      const opacity = 0.5;
      a2 = Math.floor(a2 * opacity);
      destData.data[d + 0] = Math.floor(clamp(r * a2 / 255 + (255 - a2) * r2 / 255));
      destData.data[d + 1] = Math.floor(clamp(r * a2 / 255 + (255 - a2) * g2 / 255));
      destData.data[d + 2] = Math.floor(clamp(b * a2 / 255 + (255 - a2) * b2 / 255));
      destData.data[d + 3] = 255;
    }
  }
  
  destCtx.putImageData(destData, 0, 0);
}

function rotateCanvas(context, sourceCanvas, srcX, srcY, srcW, srcH, dstX, dstY, dstW, dstH, angle) {
  const tempCanvas = document.createElement("canvas");
  tempCanvas.width = srcW * 2;
  tempCanvas.height = srcH * 2;
  const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });

  tempCtx.clearRect(0, 0, srcW, srcH);
  const x = srcW / 2;
  const y = srcH / 2;
  const angleInRadians = degToRad(angle);
  tempCtx.translate(x, y);
  tempCtx.rotate(angleInRadians);
  tempCtx.drawImage(sourceCanvas, srcX, srcY, srcW, srcH, -x, -y, srcW, srcH);
  tempCtx.rotate(-angleInRadians);
  tempCtx.translate(-x, -y);

  context.drawImage(tempCanvas, x - dstW / 2, y - dstH / 2, dstW, dstH, dstX, dstY, dstW, dstH);
  tempCanvas.remove();
  return context;
}

function degToRad(deg) {
  return deg * (Math.PI / 180);
}

function hasWebGLSupport() {
  try {
    const canvas = document.createElement('canvas');
    return !!(window.WebGLRenderingContext && (
      canvas.getContext('webgl') || canvas.getContext('experimental-webgl')
    ));
  } catch (e) {
    return false;
  }
}

// ========================================================================================
// ENCHANTMENT GLINT ANIMATION
// ========================================================================================

function generateGlintFrame(cycle) {
  const cycle2 = (cycle + 32) % 56;
  
  // Create unique canvas for this component instance
  const baseCanvas = createCanvas(64, 64);
  baseCanvas.context.fillStyle = "#000000";
  baseCanvas.context.fillRect(0, 0, 64, 64);

  // Get the specific enchant glint image for this component
  const enchantImg = document.getElementById(`enchant-glint-${componentId}`);
  if (!enchantImg) return baseCanvas.canvas;

  const enchantGlint = createCanvas(64, 64);
  enchantGlint.context.drawImage(enchantImg, 0, 0);

  const canvasWidth = Math.sqrt(2) * 64;

  // First rotation layer (80°)
  {
    const stretchCanvas = createCanvas(canvasWidth, canvasWidth);
    stretchCanvas.context.imageSmoothingEnabled = true;
    stretchCanvas.context.drawImage(enchantGlint.canvas, cycle, 0, 8, 64, 0, 0, canvasWidth, canvasWidth);

    const rotatedCanvas = createCanvas(64, 64);
    rotateCanvas(rotatedCanvas.context, stretchCanvas.canvas, 0, 0, canvasWidth, canvasWidth, 0, 0, 64, 64, 80);
    mergeCanvas(baseCanvas.canvas, rotatedCanvas.canvas);
    
    // Clean up this layer's temporary canvases immediately
    stretchCanvas.canvas.remove();
    rotatedCanvas.canvas.remove();
  }

  // Second rotation layer (-10°)
  {
    const stretchCanvas = createCanvas(canvasWidth, canvasWidth);
    stretchCanvas.context.imageSmoothingEnabled = true;
    stretchCanvas.context.drawImage(enchantGlint.canvas, 56 - cycle2, 0, 8, 64, 0, 0, canvasWidth, canvasWidth);

    const rotatedCanvas = createCanvas(64, 64);
    rotateCanvas(rotatedCanvas.context, stretchCanvas.canvas, 0, 0, canvasWidth, canvasWidth, 0, 0, 64, 64, -10);
    mergeCanvas(baseCanvas.canvas, rotatedCanvas.canvas);
    
    // Clean up this layer's temporary canvases immediately
    stretchCanvas.canvas.remove();
    rotatedCanvas.canvas.remove();
  }

  // Clean up the enchant glint canvas
  enchantGlint.canvas.remove();

  return baseCanvas.canvas;
}

// ========================================================================================
// MAIN INITIALIZATION
// ========================================================================================

function initMinecraftItem() {
  if (!hasWebGLSupport() || typeof THREE === 'undefined') {
    document.querySelector(`#canvas-${componentId}`).parentElement.classList.add('no-webgl');
    return;
  }
  
  definePixelArtGeometry();
  
  const canvas = document.getElementById(`canvas-${componentId}`);
  const itemImg = document.getElementById(`item-${componentId}`);
  let mainObject;
  
  // Wait for image to load
  if (!itemImg.complete) {
    itemImg.onload = () => initThreeJS();
  } else {
    initThreeJS();
  }
  
  function initThreeJS() {
    try {
      // Initialize renderer with transparent background
      const renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: false,
        alpha: true,
        premultipliedAlpha: false
      });
      renderer.setClearColor(0x000000, 0);
      renderer.setSize(width, height);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // Initialize scene
      const scene = new THREE.Scene();

      // Create geometry
      const tempCanvas = createCanvas(itemImg.width, itemImg.height);
      tempCanvas.context.drawImage(itemImg, 0, 0);
      const geometry = new THREE.PixelArtGeometry(tempCanvas.canvas, 1);
      tempCanvas.canvas.remove();
      
      // Create texture
      const texture = new THREE.TextureLoader().load(itemImg.src);
      texture.magFilter = THREE.NearestFilter;
      texture.minFilter = THREE.NearestFilter;
      
      // Create emissive maps for glint animation (each component gets its own)
      let emissiveMaps = [];
      if (enableGlint) {
        for (let i = 0; i < 56; i++) {
          const glintCanvas = generateGlintFrame(i);
          const emissiveTexture = new THREE.CanvasTexture(glintCanvas);
          emissiveTexture.magFilter = THREE.NearestFilter;
          emissiveTexture.minFilter = THREE.NearestFilter;
          emissiveTexture.needsUpdate = true;
          emissiveMaps.push(emissiveTexture);
        }
      }

      // Create material
      const materialConfig = {
        map: texture,
        transparent: true,
        side: THREE.DoubleSide,
        alphaTest: 0.1
      };
      
      if (enableGlint && emissiveMaps.length > 0) {
        materialConfig.emissiveMap = emissiveMaps[0];
        materialConfig.emissive = new THREE.Color("#8f22cf");
        materialConfig.emissiveIntensity = 0.6;
      }
      
      const material = new THREE.MeshLambertMaterial(materialConfig);

      // Create mesh
      const mesh = new THREE.Mesh(geometry, material);
      mesh.scale.set(size, size, size);
      mainObject = mesh;

      // Add object to scene
      scene.add(mainObject);

      // Render function
      function render() {
        // Initialize camera
        const viewSize = 300;
        const aspectRatio = width / height;
        const camera = new THREE.OrthographicCamera(
          -aspectRatio * viewSize / 2,
          aspectRatio * viewSize / 2,
          viewSize / 2,
          -viewSize / 2,
          -1000,
          1000
        );

        camera.position.set(viewSize, viewSize * 0.8168, viewSize);
        camera.lookAt(scene.position);

        // Initialize lighting
        const directionalLight = new THREE.DirectionalLight(0xFFFFFF);
        directionalLight.intensity = 0.435;
        directionalLight.position.set(-1, 2.25, 1.24).normalize();
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        const shadowDistance = 50;
        directionalLight.shadow.camera.left = -shadowDistance;
        directionalLight.shadow.camera.right = shadowDistance;
        directionalLight.shadow.camera.top = shadowDistance;
        directionalLight.shadow.camera.bottom = -shadowDistance;
        directionalLight.shadow.camera.far = 3500;
        directionalLight.shadow.bias = -0.0001;
        scene.add(directionalLight);

        const ambientLight = new THREE.AmbientLight(0xFCFCFF);
        ambientLight.intensity = 0.618;
        scene.add(ambientLight);

        // Begin animation (each component has isolated state)
        let positionCycle = rotationOffset;
        let glintCycle = 0;
        let animationId = null;

        function tick() {
          // Object position and rotation
          positionCycle = positionCycle < 360 ? positionCycle + 1 : 0;
          const yOffset = Math.sin(degToRad(positionCycle * 2)) * 20;
          mainObject.position.set(0, -yOffset, 0);
          mainObject.rotation.set(0, degToRad(positionCycle * 1), 0);
          
          // Switch emissive maps for glint effect (isolated to this component)
          if (enableGlint && emissiveMaps.length > 0) {
            const frameIndex = Math.floor(glintCycle);
            if (frameIndex < emissiveMaps.length) {
              mainObject.material.emissiveMap = emissiveMaps[frameIndex];
              mainObject.material.needsUpdate = true;
            }
            glintCycle = glintCycle < emissiveMaps.length ? glintCycle + 0.17 : 0;
          }

          // Re-render
          renderer.render(scene, camera);
          animationId = requestAnimationFrame(tick);
        }

        // Start animation
        tick();
        
        // Store cleanup function for this component
        window[`cleanup_${componentId}`] = function() {
          if (animationId) {
            cancelAnimationFrame(animationId);
          }
          if (renderer) {
            renderer.dispose();
          }
        };
      }

      render();
      
    } catch (error) {
      console.warn('Failed to initialize WebGL item:', error);
      document.querySelector(`#canvas-${componentId}`).parentElement.classList.add('no-webgl');
    }
  }
}

// Initialize when ready (keeping original flow)
document.addEventListener('DOMContentLoaded', function () {
  if (typeof THREE !== 'undefined') {
    initMinecraftItem();
  } else {
    // Wait for Three.js to load
    const checkThree = setInterval(() => {
      if (typeof THREE !== 'undefined') {
        clearInterval(checkThree);
        initMinecraftItem();
      }
    }, 100);
    
    // Fallback after 3 seconds
    setTimeout(() => {
      clearInterval(checkThree);
      if (typeof THREE === 'undefined') {
        document.querySelector(`#canvas-${componentId}`).parentElement.classList.add('no-webgl');
      }
    }, 3000);
  }
});
</script>